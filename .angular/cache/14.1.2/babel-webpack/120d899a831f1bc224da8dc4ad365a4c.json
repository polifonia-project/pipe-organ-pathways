{"ast":null,"code":"import { Component, EventEmitter, forwardRef, ViewEncapsulation, ElementRef, Renderer2, ViewChild, Input, Output, ContentChild, TemplateRef, Pipe, NgModule } from '@angular/core';\nimport { fromEvent } from 'rxjs';\nimport { map, filter, debounceTime } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete-lib.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/forms';\nconst _c0 = [\"searchInput\"];\nconst _c1 = [\"filteredListElement\"];\nconst _c2 = [\"historyListElement\"];\n\nfunction AutocompleteComponent_div_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 13);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_div_4_Template_div_click_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r11.remove($event));\n    });\n    ɵngcc0.ɵɵelementStart(1, \"i\", 14);\n    ɵngcc0.ɵɵtext(2, \"close\");\n    ɵngcc0.ɵɵelementEnd()();\n  }\n}\n\nfunction AutocompleteComponent_div_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 15);\n    ɵngcc0.ɵɵelement(1, \"div\", 16)(2, \"div\", 17)(3, \"div\", 18)(4, \"div\", 19)(5, \"div\", 20)(6, \"div\", 21)(7, \"div\", 22)(8, \"div\", 23)(9, \"div\", 24)(10, \"div\", 25)(11, \"div\", 26)(12, \"div\", 27);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction AutocompleteComponent_div_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 28)(1, \"div\", 29);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r3.heading);\n  }\n}\n\nfunction AutocompleteComponent_li_10_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nconst _c3 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction AutocompleteComponent_li_10_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r20 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 32);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_li_10_div_1_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r20);\n      const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n      const ctx_r18 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r18.select(item_r13));\n    });\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_li_10_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 33);\n    ɵngcc0.ɵɵpipe(2, \"highlight\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = ɵngcc0.ɵɵnextContext();\n    const idx_r14 = ctx_r21.index;\n    const item_r13 = ctx_r21.$implicit;\n    const ctx_r15 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"complete-selected\", idx_r14 === ctx_r15.selectedIdx);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r15.itemTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(7, _c3, ɵngcc0.ɵɵpipeBind2(2, 4, item_r13, ctx_r15.toHighlight)));\n  }\n}\n\nfunction AutocompleteComponent_li_10_div_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_li_10_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r25 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 32);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_li_10_div_2_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r25);\n      const item_r13 = ɵngcc0.ɵɵnextContext().$implicit;\n      const ctx_r23 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r23.select(item_r13));\n    });\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_li_10_div_2_ng_container_1_Template, 1, 0, \"ng-container\", 33);\n    ɵngcc0.ɵɵpipe(2, \"highlight\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r26 = ɵngcc0.ɵɵnextContext();\n    const idx_r14 = ctx_r26.index;\n    const item_r13 = ctx_r26.$implicit;\n    const ctx_r16 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"complete-selected\", idx_r14 === ctx_r16.selectedIdx);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r16.itemTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(8, _c3, ɵngcc0.ɵɵpipeBind3(2, 4, item_r13, ctx_r16.toHighlight, ctx_r16.searchKeyword)));\n  }\n}\n\nfunction AutocompleteComponent_li_10_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"li\", 30);\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_li_10_div_1_Template, 3, 9, \"div\", 31);\n    ɵngcc0.ɵɵtemplate(2, AutocompleteComponent_li_10_div_2_Template, 3, 10, \"div\", 31);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const item_r13 = ctx.$implicit;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.isTypeString(item_r13));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r5.isTypeString(item_r13));\n  }\n}\n\nfunction AutocompleteComponent_div_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r28 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 28)(1, \"div\", 29);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(3, \"div\", 13);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_div_12_Template_div_click_3_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r28);\n      const ctx_r27 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r27.resetHistoryList($event));\n    });\n    ɵngcc0.ɵɵelementStart(4, \"i\", 14);\n    ɵngcc0.ɵɵtext(5, \"delete\");\n    ɵngcc0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r6.historyHeading);\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r36 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 32);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_li_15_div_1_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r36);\n      const item_r29 = ɵngcc0.ɵɵnextContext().$implicit;\n      const ctx_r34 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r34.select(item_r29));\n    });\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_li_15_div_1_ng_container_1_Template, 1, 0, \"ng-container\", 33);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r37 = ɵngcc0.ɵɵnextContext();\n    const idx_r30 = ctx_r37.index;\n    const item_r29 = ctx_r37.$implicit;\n    const ctx_r31 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"complete-selected\", idx_r30 === ctx_r31.selectedIdx);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r31.itemTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(4, _c3, item_r29));\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_li_15_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r41 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 32);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_li_15_div_2_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r41);\n      const item_r29 = ɵngcc0.ɵɵnextContext().$implicit;\n      const ctx_r39 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r39.select(item_r29));\n    });\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_li_15_div_2_ng_container_1_Template, 1, 0, \"ng-container\", 33);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r42 = ɵngcc0.ɵɵnextContext();\n    const idx_r30 = ctx_r42.index;\n    const item_r29 = ctx_r42.$implicit;\n    const ctx_r32 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassProp(\"complete-selected\", idx_r30 === ctx_r32.selectedIdx);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r32.itemTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(4, _c3, item_r29));\n  }\n}\n\nfunction AutocompleteComponent_li_15_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r44 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 30);\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_li_15_div_1_Template, 2, 6, \"div\", 31);\n    ɵngcc0.ɵɵtemplate(2, AutocompleteComponent_li_15_div_2_Template, 2, 6, \"div\", 31);\n    ɵngcc0.ɵɵelementStart(3, \"div\", 13);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_li_15_Template_div_click_3_listener($event) {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r44);\n      const idx_r30 = restoredCtx.index;\n      const ctx_r43 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r43.removeHistoryItem(idx_r30, $event));\n    });\n    ɵngcc0.ɵɵelementStart(4, \"i\", 14);\n    ɵngcc0.ɵɵtext(5, \"close\");\n    ɵngcc0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const item_r29 = ctx.$implicit;\n    const ctx_r8 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r8.isTypeString(item_r29));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r8.isTypeString(item_r29));\n  }\n}\n\nfunction AutocompleteComponent_div_16_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainer(0);\n  }\n}\n\nfunction AutocompleteComponent_div_16_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 34);\n    ɵngcc0.ɵɵtemplate(1, AutocompleteComponent_div_16_ng_container_1_Template, 1, 0, \"ng-container\", 33);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r9.notFoundTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx_r9.notFoundText));\n  }\n}\n\nfunction AutocompleteComponent_div_17_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r47 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 35);\n    ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_div_17_Template_div_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r47);\n      const ctx_r46 = ɵngcc0.ɵɵnextContext();\n      return ɵngcc0.ɵɵresetView(ctx_r46.handleOverlay());\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nconst _c4 = function (a0) {\n  return {\n    \"active\": a0\n  };\n};\n\nconst _c5 = function (a0, a1) {\n  return {\n    \"is-hidden\": a0,\n    \"is-visible\": a1\n  };\n};\n\nlet AutocompleteLibComponent = /*#__PURE__*/(() => {\n  class AutocompleteLibComponent {\n    constructor() {}\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {}\n\n  }\n\n  AutocompleteLibComponent.ɵfac = function AutocompleteLibComponent_Factory(t) {\n    return new (t || AutocompleteLibComponent)();\n  };\n\n  AutocompleteLibComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: AutocompleteLibComponent,\n    selectors: [[\"ng-autocomplete-lib\"]],\n    decls: 2,\n    vars: 0,\n    template: function AutocompleteLibComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"p\");\n        ɵngcc0.ɵɵtext(1, \" autocomplete-lib works! \");\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return AutocompleteLibComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete/autocomplete.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Keyboard events\n * @type {?}\n */\n\n\nconst isArrowUp =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 38;\n\nconst ɵ0 = isArrowUp;\n/** @type {?} */\n\nconst isArrowDown =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 40;\n\nconst ɵ1 = isArrowDown;\n/** @type {?} */\n\nconst isArrowUpDown =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => isArrowUp(keyCode) || isArrowDown(keyCode);\n\nconst ɵ2 = isArrowUpDown;\n/** @type {?} */\n\nconst isEnter =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 13;\n\nconst ɵ3 = isEnter;\n/** @type {?} */\n\nconst isBackspace =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 8;\n\nconst ɵ4 = isBackspace;\n/** @type {?} */\n\nconst isDelete =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 46;\n\nconst ɵ5 = isDelete;\n/** @type {?} */\n\nconst isESC =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 27;\n\nconst ɵ6 = isESC;\n/** @type {?} */\n\nconst isTab =\n/**\n* @param {?} keyCode\n* @return {?}\n*/\nkeyCode => keyCode === 9;\n\nconst ɵ7 = isTab;\nlet AutocompleteComponent = /*#__PURE__*/(() => {\n  class AutocompleteComponent {\n    /**\n     * @param {?} elementRef\n     * @param {?} renderer\n     */\n    constructor(elementRef, renderer) {\n      this.renderer = renderer;\n      this.query = ''; // search query\n      // search query\n\n      this.filteredList = []; // list of items\n      // list of items\n\n      this.historyList = []; // list of history items\n      // list of history items\n\n      this.isHistoryListVisible = true;\n      this.selectedIdx = -1;\n      this.toHighlight = '';\n      this.notFound = false;\n      this.isFocused = false;\n      this.isOpen = false;\n      this.isScrollToEnd = false;\n      this.overlay = false;\n      this.manualOpen = undefined;\n      this.manualClose = undefined; // @Inputs\n\n      /**\n       * Data of items list.\n       * It can be array of strings or array of objects.\n       */\n\n      this.data = []; // keyword to filter the list\n\n      this.placeholder = '';\n      this.heading = '';\n      /**\n       * Heading text of history list.\n       * If it is null then history heading is hidden.\n       */\n\n      this.historyHeading = 'Recently selected';\n      this.historyListMaxNumber = 15; // maximum number of items in the history list.\n      // maximum number of items in the history list.\n\n      this.notFoundText = 'Not found'; // set custom text when filter returns empty result\n      // input disable/enable\n\n      /**\n       * The minimum number of characters the user must type before a search is performed.\n       */\n\n      this.minQueryLength = 1;\n      /**\n       * Focus first item in the list\n       */\n\n      this.focusFirst = false; // @Output events\n\n      /**\n       * Event that is emitted whenever an item from the list is selected.\n       */\n\n      this.selected = new EventEmitter();\n      /**\n       * Event that is emitted whenever an input is changed.\n       */\n\n      this.inputChanged = new EventEmitter();\n      /**\n       * Event that is emitted whenever an input is focused.\n       */\n\n      this.inputFocused = new EventEmitter();\n      /**\n       * Event that is emitted whenever an input is cleared.\n       */\n\n      this.inputCleared = new EventEmitter();\n      /**\n       * Event that is emitted when the autocomplete panel is opened.\n       */\n\n      this.opened = new EventEmitter();\n      /**\n       * Event that is emitted when the autocomplete panel is closed.\n       */\n\n      this.closed = new EventEmitter();\n      /**\n       * Event that is emitted when scrolled to the end of items.\n       */\n\n      this.scrolledToEnd = new EventEmitter();\n      /**\n       * Propagates new value when model changes\n       */\n\n      this.propagateChange =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      this.onTouched =\n      /**\n      * @return {?}\n      */\n      () => {};\n\n      this.elementRef = elementRef;\n    }\n    /**\n     * Writes a new value from the form model into the view,\n     * Updates model\n     * @param {?=} value\n     * @return {?}\n     */\n\n\n    writeValue(value = '') {\n      this.query = value && !this.isTypeString(value) ? value[this.searchKeyword] : value;\n    }\n    /**\n     * Registers a handler that is called when something in the view has changed\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n    /**\n     * Registers a handler specifically for when a control receives a touch event\n     * @param {?} fn\n     * @return {?}\n     */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * Event that is called when the value of an input element is changed\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    onChange(event) {\n      this.propagateChange(event.target.value);\n    }\n    /**\n     * Event that is called when the control status changes to or from DISABLED\n     * @param {?} isDisabled\n     * @return {?}\n     */\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {}\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      this.initEventStream();\n      this.handleScroll();\n    }\n    /**\n     * Set initial value\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    setInitialValue(value) {\n      if (this.initialValue) {\n        this.select(value);\n      }\n    }\n    /**\n     * Update search results\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      this.setInitialValue(this.initialValue);\n\n      if (changes && changes.data && Array.isArray(changes.data.currentValue)) {\n        this.handleItemsChange();\n\n        if (!changes.data.firstChange && this.isFocused) {\n          this.handleOpen();\n        }\n      }\n    }\n    /**\n     * Items change\n     * @return {?}\n     */\n\n\n    handleItemsChange() {\n      this.isScrollToEnd = false;\n\n      if (!this.isOpen) {\n        return;\n      }\n\n      this.filteredList = this.data;\n      this.notFound = !this.filteredList || this.filteredList.length === 0; // Filter list when updating data and panel is open\n\n      if (this.isOpen) {\n        this.filterList();\n      }\n    }\n    /**\n     * Filter data\n     * @return {?}\n     */\n\n\n    filterList() {\n      this.selectedIdx = -1;\n      this.initSearchHistory();\n\n      if (this.query != null && this.data) {\n        this.toHighlight = this.query;\n        this.filteredList = this.customFilter !== undefined ? this.customFilter([...this.data], this.query) : this.defaultFilterFunction(); // If [focusFirst]=\"true\" automatically focus the first match\n\n        if (this.filteredList.length > 0 && this.focusFirst) {\n          this.selectedIdx = 0;\n        }\n      } else {\n        this.notFound = false;\n      }\n    }\n    /**\n     * Default filter function, used unless customFilter is provided\n     * @return {?}\n     */\n\n\n    defaultFilterFunction() {\n      return this.data.filter(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      item => {\n        if (typeof item === 'string') {\n          // string logic, check equality of strings\n          return item.toLowerCase().indexOf(this.query.toLowerCase()) > -1;\n        } else if (typeof item === 'object' && item instanceof Object) {\n          // object logic, check property equality\n          return item[this.searchKeyword].toLowerCase().indexOf(this.query.toLowerCase()) > -1;\n        }\n      });\n    }\n    /**\n     * Check if item is a string in the list.\n     * @param {?} item\n     * @return {?}\n     */\n\n\n    isTypeString(item) {\n      return typeof item === 'string';\n    }\n    /**\n     * Select item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n\n\n    select(item) {\n      this.query = !this.isTypeString(item) ? item[this.searchKeyword] : item;\n      this.isOpen = true;\n      this.overlay = false;\n      this.selected.emit(item);\n      this.propagateChange(item);\n\n      if (this.initialValue) {\n        // check if history already exists in localStorage and then update\n\n        /** @type {?} */\n        const history = window.localStorage.getItem(`${this.historyIdentifier}`);\n\n        if (history) {\n          /** @type {?} */\n          let existingHistory = JSON.parse(localStorage[`${this.historyIdentifier}`]);\n          if (!(existingHistory instanceof Array)) existingHistory = []; // check if selected item exists in existingHistory\n\n          if (!existingHistory.some(\n          /**\n          * @param {?} existingItem\n          * @return {?}\n          */\n          existingItem => !this.isTypeString(existingItem) ? existingItem[this.searchKeyword] == item[this.searchKeyword] : existingItem == item)) {\n            existingHistory.unshift(item);\n            localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(existingHistory)); // check if items don't exceed max allowed number\n\n            if (existingHistory.length >= this.historyListMaxNumber) {\n              existingHistory.splice(existingHistory.length - 1, 1);\n              localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(existingHistory));\n            }\n          } else {\n            // if selected item exists in existingHistory swap to top in array\n            if (!this.isTypeString(item)) {\n              // object logic\n\n              /** @type {?} */\n              const copiedExistingHistory = existingHistory.slice(); // copy original existingHistory array\n\n              /** @type {?} */\n\n              const selectedIndex = copiedExistingHistory.map(\n              /**\n              * @param {?} el\n              * @return {?}\n              */\n              el => el[this.searchKeyword]).indexOf(item[this.searchKeyword]);\n              copiedExistingHistory.splice(selectedIndex, 1);\n              copiedExistingHistory.splice(0, 0, item);\n              localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(copiedExistingHistory));\n            } else {\n              // string logic\n\n              /** @type {?} */\n              const copiedExistingHistory = existingHistory.slice();\n              copiedExistingHistory.splice(copiedExistingHistory.indexOf(item), 1);\n              copiedExistingHistory.splice(0, 0, item);\n              localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(copiedExistingHistory));\n            }\n          }\n        } else {\n          this.saveHistory(item);\n        }\n      } else {\n        this.saveHistory(item);\n      }\n\n      this.handleClose();\n    }\n    /**\n     * Document click\n     * @param {?} e event\n     * @return {?}\n     */\n\n\n    handleClick(e) {\n      /** @type {?} */\n      let clickedComponent = e.target;\n      /** @type {?} */\n\n      let inside = false;\n\n      do {\n        if (clickedComponent === this.elementRef.nativeElement) {\n          inside = true;\n\n          if (this.filteredList.length) {\n            this.handleOpen();\n          }\n        }\n\n        clickedComponent = clickedComponent.parentNode;\n      } while (clickedComponent);\n\n      if (!inside) {\n        this.handleClose();\n      }\n    }\n    /**\n     * Handle body overlay\n     * @return {?}\n     */\n\n\n    handleOverlay() {\n      this.overlay = false;\n    }\n    /**\n     * Scroll items\n     * @return {?}\n     */\n\n\n    handleScroll() {\n      this.renderer.listen(this.filteredListElement.nativeElement, 'scroll',\n      /**\n      * @return {?}\n      */\n      () => {\n        this.scrollToEnd();\n      });\n    }\n    /**\n     * Define panel state\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    setPanelState(event) {\n      if (event) {\n        event.stopPropagation();\n      } // If controls are untouched\n\n\n      if (typeof this.manualOpen === 'undefined' && typeof this.manualClose === 'undefined') {\n        this.isOpen = false;\n        this.handleOpen();\n      } // If one of the controls is untouched and other is deactivated\n\n\n      if (typeof this.manualOpen === 'undefined' && this.manualClose === false || typeof this.manualClose === 'undefined' && this.manualOpen === false) {\n        this.isOpen = false;\n        this.handleOpen();\n      } // if controls are touched but both are deactivated\n\n\n      if (this.manualOpen === false && this.manualClose === false) {\n        this.isOpen = false;\n        this.handleOpen();\n      } // if open control is touched and activated\n\n\n      if (this.manualOpen) {\n        this.isOpen = false;\n        this.handleOpen();\n        this.manualOpen = false;\n      } // if close control is touched and activated\n\n\n      if (this.manualClose) {\n        this.isOpen = true;\n        this.handleClose();\n        this.manualClose = false;\n      }\n    }\n    /**\n     * Manual controls\n     * @return {?}\n     */\n\n\n    open() {\n      this.manualOpen = true;\n      this.isOpen = false;\n      this.handleOpen();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    close() {\n      this.manualClose = true;\n      this.isOpen = true;\n      this.handleClose();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    focus() {\n      this.handleFocus(event);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    clear() {\n      this.remove(event);\n    }\n    /**\n     * Remove search query\n     * @param {?} e\n     * @return {?}\n     */\n\n\n    remove(e) {\n      e.stopPropagation();\n      this.query = '';\n      this.inputCleared.emit();\n      this.propagateChange(this.query);\n      this.setPanelState(e);\n\n      if (this.data && !this.data.length) {\n        this.notFound = false;\n      }\n    }\n    /**\n     * Initialize historyList search\n     * @return {?}\n     */\n\n\n    initSearchHistory() {\n      this.isHistoryListVisible = false;\n\n      if (this.historyIdentifier && !this.query) {\n        /** @type {?} */\n        const history = window.localStorage.getItem(`${this.historyIdentifier}`);\n\n        if (history) {\n          this.isHistoryListVisible = true;\n          this.filteredList = [];\n          this.historyList = history ? JSON.parse(history) : [];\n        } else {\n          this.isHistoryListVisible = false;\n        }\n      } else {\n        this.isHistoryListVisible = false;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    handleOpen() {\n      if (this.isOpen || this.isOpen && !this.isLoading) {\n        return;\n      } // If data exists\n\n\n      if (this.data && this.data.length) {\n        this.isOpen = true;\n        this.overlay = true;\n        this.filterList();\n        this.opened.emit();\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    handleClose() {\n      if (!this.isOpen) {\n        this.isFocused = false;\n        return;\n      }\n\n      this.isOpen = false;\n      this.overlay = false;\n      this.filteredList = [];\n      this.selectedIdx = -1;\n      this.notFound = false;\n      this.isHistoryListVisible = false;\n      this.isFocused = false;\n      this.closed.emit();\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n\n\n    handleFocus(e) {\n      this.searchInput.nativeElement.focus();\n\n      if (this.isFocused) {\n        return;\n      }\n\n      this.inputFocused.emit(e); // if data exists then open\n\n      if (this.data && this.data.length) {\n        this.setPanelState(event);\n      }\n\n      this.isFocused = true;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    scrollToEnd() {\n      if (this.isScrollToEnd) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const scrollTop = this.filteredListElement.nativeElement.scrollTop;\n      /** @type {?} */\n\n      const scrollHeight = this.filteredListElement.nativeElement.scrollHeight;\n      /** @type {?} */\n\n      const elementHeight = this.filteredListElement.nativeElement.clientHeight;\n      /** @type {?} */\n\n      const atBottom = scrollHeight === scrollTop + elementHeight;\n\n      if (atBottom) {\n        this.scrolledToEnd.emit();\n        this.isScrollToEnd = true;\n      }\n    }\n    /**\n     * Initialize keyboard events\n     * @return {?}\n     */\n\n\n    initEventStream() {\n      this.inputKeyUp$ = fromEvent(this.searchInput.nativeElement, 'keyup').pipe(map(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => e));\n      this.inputKeyDown$ = fromEvent(this.searchInput.nativeElement, 'keydown').pipe(map(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => e));\n      this.listenEventStream();\n    }\n    /**\n     * Listen keyboard events\n     * @return {?}\n     */\n\n\n    listenEventStream() {\n      // key up event\n      this.inputKeyUp$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => !isArrowUpDown(e.keyCode) && !isEnter(e.keyCode) && !isESC(e.keyCode) && !isTab(e.keyCode)), debounceTime(this.debounceTime)).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.onKeyUp(e);\n      }); // cursor up & down\n\n      this.inputKeyDown$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => isArrowUpDown(e.keyCode))).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        e.preventDefault();\n        this.onFocusItem(e);\n      }); // enter keyup\n\n      this.inputKeyUp$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => isEnter(e.keyCode))).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {//this.onHandleEnter();\n      }); // enter keydown\n\n      this.inputKeyDown$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => isEnter(e.keyCode))).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.onHandleEnter();\n      }); // ESC\n\n      this.inputKeyUp$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => isESC(e.keyCode), debounceTime(100))).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.onEsc();\n      }); // TAB\n\n      this.inputKeyDown$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => isTab(e.keyCode))).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.onTab();\n      }); // delete\n\n      this.inputKeyDown$.pipe(filter(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => isBackspace(e.keyCode) || isDelete(e.keyCode))).subscribe(\n      /**\n      * @param {?} e\n      * @return {?}\n      */\n      e => {\n        this.onDelete();\n      });\n    }\n    /**\n     * on keyup == when input changed\n     * @param {?} e event\n     * @return {?}\n     */\n\n\n    onKeyUp(e) {\n      this.notFound = false; // search results are unknown while typing\n      // if input is empty\n\n      if (!this.query) {\n        this.notFound = false;\n        this.inputChanged.emit(e.target.value);\n        this.inputCleared.emit();\n        this.setPanelState(e);\n      } // note that '' can be a valid query\n\n\n      if (!this.query && this.query !== '') {\n        return;\n      } // if query >= to minQueryLength\n\n\n      if (this.query.length >= this.minQueryLength) {\n        this.inputChanged.emit(e.target.value);\n        this.filterList(); // If no results found\n\n        if (!this.filteredList.length && !this.isLoading) {\n          this.notFoundText ? this.notFound = true : this.notFound = false;\n        }\n\n        if (this.data && !this.data.length) {\n          this.isOpen = true;\n        }\n      }\n    }\n    /**\n     * Keyboard arrow top and arrow bottom\n     * @param {?} e event\n     * @return {?}\n     */\n\n\n    onFocusItem(e) {\n      // move arrow up and down on filteredList or historyList\n      if (!this.historyList.length || !this.isHistoryListVisible) {\n        // filteredList\n\n        /** @type {?} */\n        const totalNumItem = this.filteredList.length;\n\n        if (e.key === 'ArrowDown') {\n          /** @type {?} */\n          let sum = this.selectedIdx;\n          sum = this.selectedIdx === null ? 0 : sum + 1;\n          this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        } else if (e.key === 'ArrowUp') {\n          if (this.selectedIdx == -1) {\n            this.selectedIdx = 0;\n          }\n\n          this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        }\n      } else {\n        // historyList\n\n        /** @type {?} */\n        const totalNumItem = this.historyList.length;\n\n        if (e.key === 'ArrowDown') {\n          /** @type {?} */\n          let sum = this.selectedIdx;\n          sum = this.selectedIdx === null ? 0 : sum + 1;\n          this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        } else if (e.key === 'ArrowUp') {\n          if (this.selectedIdx == -1) {\n            this.selectedIdx = 0;\n          }\n\n          this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n          this.scrollToFocusedItem(this.selectedIdx);\n        }\n      }\n    }\n    /**\n     * Scroll to focused item\n     * * \\@param index\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    scrollToFocusedItem(index) {\n      /** @type {?} */\n      let listElement = null; // Define list element\n\n      if (!this.historyList.length || !this.isHistoryListVisible) {\n        // filteredList element\n        listElement = this.filteredListElement.nativeElement;\n      } else {\n        // historyList element\n        listElement = this.historyListElement.nativeElement;\n      }\n      /** @type {?} */\n\n\n      const items = Array.prototype.slice.call(listElement.childNodes).filter(\n      /**\n      * @param {?} node\n      * @return {?}\n      */\n      node => {\n        if (node.nodeType === 1) {\n          // if node is element\n          return node.className.includes('item');\n        } else {\n          return false;\n        }\n      });\n\n      if (!items.length) {\n        return;\n      }\n      /** @type {?} */\n\n\n      const listHeight = listElement.offsetHeight;\n      /** @type {?} */\n\n      const itemHeight = items[index].offsetHeight;\n      /** @type {?} */\n\n      const visibleTop = listElement.scrollTop;\n      /** @type {?} */\n\n      const visibleBottom = listElement.scrollTop + listHeight - itemHeight;\n      /** @type {?} */\n\n      const targetPosition = items[index].offsetTop;\n\n      if (targetPosition < visibleTop) {\n        listElement.scrollTop = targetPosition;\n      }\n\n      if (targetPosition > visibleBottom) {\n        listElement.scrollTop = targetPosition - listHeight + itemHeight;\n      }\n    }\n    /**\n     * Select item on enter click\n     * @return {?}\n     */\n\n\n    onHandleEnter() {\n      // click enter to choose item from filteredList or historyList\n      if (this.selectedIdx > -1) {\n        if (!this.historyList.length || !this.isHistoryListVisible) {\n          // filteredList\n          this.query = !this.isTypeString(this.filteredList[this.selectedIdx]) ? this.filteredList[this.selectedIdx][this.searchKeyword] : this.filteredList[this.selectedIdx];\n          this.saveHistory(this.filteredList[this.selectedIdx]);\n          this.select(this.filteredList[this.selectedIdx]);\n        } else {\n          // historyList\n          this.query = !this.isTypeString(this.historyList[this.selectedIdx]) ? this.historyList[this.selectedIdx][this.searchKeyword] : this.historyList[this.selectedIdx];\n          this.saveHistory(this.historyList[this.selectedIdx]);\n          this.select(this.historyList[this.selectedIdx]);\n        }\n      }\n\n      this.isHistoryListVisible = false;\n      this.handleClose();\n    }\n    /**\n     * Esc click\n     * @return {?}\n     */\n\n\n    onEsc() {\n      this.searchInput.nativeElement.blur();\n      this.handleClose();\n    }\n    /**\n     * Tab click\n     * @return {?}\n     */\n\n\n    onTab() {\n      this.searchInput.nativeElement.blur();\n      this.handleClose();\n    }\n    /**\n     * Delete click\n     * @return {?}\n     */\n\n\n    onDelete() {\n      this.isOpen = true;\n    }\n    /**\n     * Select item to save in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n\n\n    saveHistory(selected) {\n      if (this.historyIdentifier) {\n        // check if selected item exists in historyList\n        if (!this.historyList.some(\n        /**\n        * @param {?} item\n        * @return {?}\n        */\n        item => !this.isTypeString(item) ? item[this.searchKeyword] == selected[this.searchKeyword] : item == selected)) {\n          this.saveHistoryToLocalStorage([selected, ...this.historyList]); // check if items don't exceed max allowed number\n\n          if (this.historyList.length >= this.historyListMaxNumber) {\n            this.historyList.splice(this.historyList.length - 1, 1);\n            this.saveHistoryToLocalStorage([selected, ...this.historyList]);\n          }\n        } else {\n          // if selected item exists in historyList swap to top in array\n          if (!this.isTypeString(selected)) {\n            // object logic\n\n            /** @type {?} */\n            const copiedHistoryList = this.historyList.slice(); // copy original historyList array\n\n            /** @type {?} */\n\n            const selectedIndex = copiedHistoryList.map(\n            /**\n            * @param {?} item\n            * @return {?}\n            */\n            item => item[this.searchKeyword]).indexOf(selected[this.searchKeyword]);\n            copiedHistoryList.splice(selectedIndex, 1);\n            copiedHistoryList.splice(0, 0, selected);\n            this.saveHistoryToLocalStorage([...copiedHistoryList]);\n          } else {\n            // string logic\n\n            /** @type {?} */\n            const copiedHistoryList = this.historyList.slice();\n            copiedHistoryList.splice(this.historyList.indexOf(selected), 1);\n            copiedHistoryList.splice(0, 0, selected);\n            this.saveHistoryToLocalStorage([...copiedHistoryList]);\n          }\n        }\n      }\n    }\n    /**\n     * Save item in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n\n\n    saveHistoryToLocalStorage(selected) {\n      window.localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(selected));\n    }\n    /**\n     * Remove item from localStorage\n     * @param {?} index\n     * @param {?} e event\n     * @return {?}\n     */\n\n\n    removeHistoryItem(index, e) {\n      e.stopPropagation();\n      this.historyList = this.historyList.filter(\n      /**\n      * @param {?} v\n      * @param {?} i\n      * @return {?}\n      */\n      (v, i) => i !== index);\n      this.saveHistoryToLocalStorage(this.historyList);\n\n      if (this.historyList.length == 0) {\n        window.localStorage.removeItem(`${this.historyIdentifier}`);\n        this.filterList();\n      }\n    }\n    /**\n     * Reset localStorage\n     * @param {?} e event\n     * @return {?}\n     */\n\n\n    resetHistoryList(e) {\n      e.stopPropagation();\n      this.historyList = [];\n      window.localStorage.removeItem(`${this.historyIdentifier}`);\n      this.filterList();\n    }\n\n  }\n\n  AutocompleteComponent.ɵfac = function AutocompleteComponent_Factory(t) {\n    return new (t || AutocompleteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  AutocompleteComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: AutocompleteComponent,\n    selectors: [[\"ng-autocomplete\"]],\n    contentQueries: function AutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customTemplate = _t.first);\n      }\n    },\n    viewQuery: function AutocompleteComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchInput = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filteredListElement = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.historyListElement = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ng-autocomplete\"],\n    hostBindings: function AutocompleteComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function AutocompleteComponent_click_HostBindingHandler($event) {\n          return ctx.handleClick($event);\n        }, false, ɵngcc0.ɵɵresolveDocument);\n      }\n    },\n    inputs: {\n      data: \"data\",\n      placeholder: \"placeholder\",\n      heading: \"heading\",\n      historyHeading: \"historyHeading\",\n      historyListMaxNumber: \"historyListMaxNumber\",\n      notFoundText: \"notFoundText\",\n      minQueryLength: \"minQueryLength\",\n      focusFirst: \"focusFirst\",\n      disabled: \"disabled\",\n      searchKeyword: \"searchKeyword\",\n      initialValue: \"initialValue\",\n      historyIdentifier: \"historyIdentifier\",\n      isLoading: \"isLoading\",\n      debounceTime: \"debounceTime\",\n      customFilter: \"customFilter\",\n      itemTemplate: \"itemTemplate\",\n      notFoundTemplate: \"notFoundTemplate\"\n    },\n    outputs: {\n      selected: \"selected\",\n      inputChanged: \"inputChanged\",\n      inputFocused: \"inputFocused\",\n      inputCleared: \"inputCleared\",\n      opened: \"opened\",\n      closed: \"closed\",\n      scrolledToEnd: \"scrolledToEnd\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(\n      /**\n      * @return {?}\n      */\n      () => AutocompleteComponent),\n      multi: true\n    }]), ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 18,\n    vars: 22,\n    consts: [[1, \"autocomplete-container\", 3, \"ngClass\"], [1, \"input-container\"], [\"type\", \"text\", \"autocomplete\", \"off\", 3, \"placeholder\", \"ngModel\", \"disabled\", \"ngModelChange\", \"input\", \"focus\", \"blur\"], [\"searchInput\", \"\"], [\"class\", \"x\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"sk-fading-circle\", 4, \"ngIf\"], [1, \"suggestions-container\", 3, \"ngClass\"], [\"class\", \"heading\", 4, \"ngIf\"], [\"filteredListElement\", \"\"], [\"class\", \"item\", 4, \"ngFor\", \"ngForOf\"], [\"historyListElement\", \"\"], [\"class\", \"not-found\", 4, \"ngIf\"], [\"class\", \"autocomplete-overlay\", 3, \"click\", 4, \"ngIf\"], [1, \"x\", 3, \"click\"], [1, \"material-icons\"], [1, \"sk-fading-circle\"], [1, \"sk-circle1\", \"sk-circle\"], [1, \"sk-circle2\", \"sk-circle\"], [1, \"sk-circle3\", \"sk-circle\"], [1, \"sk-circle4\", \"sk-circle\"], [1, \"sk-circle5\", \"sk-circle\"], [1, \"sk-circle6\", \"sk-circle\"], [1, \"sk-circle7\", \"sk-circle\"], [1, \"sk-circle8\", \"sk-circle\"], [1, \"sk-circle9\", \"sk-circle\"], [1, \"sk-circle10\", \"sk-circle\"], [1, \"sk-circle11\", \"sk-circle\"], [1, \"sk-circle12\", \"sk-circle\"], [1, \"heading\"], [1, \"text\"], [1, \"item\"], [3, \"complete-selected\", \"click\", 4, \"ngIf\"], [3, \"click\"], [4, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"not-found\"], [1, \"autocomplete-overlay\", 3, \"click\"]],\n    template: function AutocompleteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"input\", 2, 3);\n        ɵngcc0.ɵɵlistener(\"ngModelChange\", function AutocompleteComponent_Template_input_ngModelChange_2_listener($event) {\n          return ctx.query = $event;\n        })(\"input\", function AutocompleteComponent_Template_input_input_2_listener($event) {\n          return ctx.onChange($event);\n        })(\"focus\", function AutocompleteComponent_Template_input_focus_2_listener($event) {\n          return ctx.handleFocus($event);\n        })(\"blur\", function AutocompleteComponent_Template_input_blur_2_listener($event) {\n          return ctx.onTouched($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, AutocompleteComponent_div_4_Template, 3, 0, \"div\", 4);\n        ɵngcc0.ɵɵtemplate(5, AutocompleteComponent_div_5_Template, 13, 0, \"div\", 5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(6, \"div\", 6);\n        ɵngcc0.ɵɵtemplate(7, AutocompleteComponent_div_7_Template, 3, 1, \"div\", 7);\n        ɵngcc0.ɵɵelementStart(8, \"ul\", null, 8);\n        ɵngcc0.ɵɵtemplate(10, AutocompleteComponent_li_10_Template, 3, 2, \"li\", 9);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵelementStart(11, \"div\", 6);\n        ɵngcc0.ɵɵtemplate(12, AutocompleteComponent_div_12_Template, 6, 1, \"div\", 7);\n        ɵngcc0.ɵɵelementStart(13, \"ul\", null, 10);\n        ɵngcc0.ɵɵtemplate(15, AutocompleteComponent_li_15_Template, 6, 2, \"li\", 9);\n        ɵngcc0.ɵɵelementEnd()();\n        ɵngcc0.ɵɵtemplate(16, AutocompleteComponent_div_16_Template, 2, 4, \"div\", 11);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(17, AutocompleteComponent_div_17_Template, 1, 0, \"div\", 12);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(14, _c4, ctx.isOpen));\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵpropertyInterpolate(\"placeholder\", ctx.placeholder);\n        ɵngcc0.ɵɵproperty(\"ngModel\", ctx.query)(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.query && !ctx.isLoading && !ctx.disabled);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.isLoading);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(16, _c5, ctx.isHistoryListVisible, !ctx.isHistoryListVisible));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.filteredList.length > 0 && ctx.heading);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.filteredList);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(19, _c5, !ctx.isHistoryListVisible, ctx.isHistoryListVisible));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.historyList.length > 0 && ctx.historyHeading);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.historyList);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.isLoading ? !ctx.isLoading && ctx.notFound : ctx.notFound);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.overlay);\n      }\n    },\n    dependencies: function () {\n      return [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc1.NgTemplateOutlet, ɵngcc2.DefaultValueAccessor, ɵngcc2.NgControlStatus, ɵngcc2.NgModel, HighlightPipe];\n    },\n    styles: [\"@import url(https://fonts.googleapis.com/icon?family=Material+Icons);.ng-autocomplete{width:600px}.autocomplete-container{box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);position:relative;overflow:visible;height:40px}.autocomplete-container .input-container input{font-size:14px;box-sizing:border-box;border:none;box-shadow:none;outline:0;background-color:#fff;color:rgba(0,0,0,.87);width:100%;padding:0 15px;line-height:40px;height:40px}.autocomplete-container .input-container input:disabled{background-color:#eee;color:#666}.autocomplete-container .input-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.autocomplete-container .input-container .x i{color:rgba(0,0,0,.54);font-size:22px;vertical-align:middle}.autocomplete-container .suggestions-container{position:absolute;width:100%;background:#fff;height:auto;box-shadow:0 2px 5px rgba(0,0,0,.25);box-sizing:border-box}.autocomplete-container .suggestions-container ul{padding:0;margin:0;max-height:240px;overflow-y:auto}.autocomplete-container .suggestions-container ul li{position:relative;list-style:none;padding:0;margin:0;cursor:pointer}.autocomplete-container .suggestions-container ul li a{padding:14px 15px;display:block;text-decoration:none;cursor:pointer;color:rgba(0,0,0,.87);font-size:15px}.autocomplete-container .suggestions-container .complete-selected,.autocomplete-container .suggestions-container ul li:hover{background-color:rgba(158,158,158,.18)}.autocomplete-container .suggestions-container .heading{position:relative;padding:10px 15px;border:1px solid #f1f1f1}.autocomplete-container .suggestions-container .heading .text{font-size:.85em}.autocomplete-container .suggestions-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.autocomplete-container .suggestions-container .x i{color:rgba(0,0,0,.54);font-size:18px;vertical-align:middle}.autocomplete-container .suggestions-container.is-hidden{visibility:hidden}.autocomplete-container .suggestions-container.is-visible{visibility:visible}.autocomplete-container .not-found{padding:0 .75em;border:1px solid #f1f1f1;background:#fff}.autocomplete-container .not-found div{padding:.4em 0;font-size:.95em;line-height:1.4;border-bottom:1px solid rgba(230,230,230,.7)}.autocomplete-container.active{z-index:999}.highlight{font-weight:700}.autocomplete-overlay{position:fixed;background-color:transparent;width:100%;height:100%;top:0;right:0;bottom:0;left:0;z-index:50}input[type=text]::-ms-clear{display:none}.sk-fading-circle{width:20px;height:20px;position:absolute;right:10px;top:0;bottom:0;margin:auto}.sk-fading-circle .sk-circle{width:100%;height:100%;position:absolute;left:0;top:0}.sk-fading-circle .sk-circle:before{content:\\\"\\\";display:block;margin:0 auto;width:15%;height:15%;background-color:#333;border-radius:100%;-webkit-animation:1.2s ease-in-out infinite both sk-circleFadeDelay;animation:1.2s ease-in-out infinite both sk-circleFadeDelay}.sk-fading-circle .sk-circle2{-webkit-transform:rotate(30deg);transform:rotate(30deg)}.sk-fading-circle .sk-circle3{-webkit-transform:rotate(60deg);transform:rotate(60deg)}.sk-fading-circle .sk-circle4{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.sk-fading-circle .sk-circle5{-webkit-transform:rotate(120deg);transform:rotate(120deg)}.sk-fading-circle .sk-circle6{-webkit-transform:rotate(150deg);transform:rotate(150deg)}.sk-fading-circle .sk-circle7{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.sk-fading-circle .sk-circle8{-webkit-transform:rotate(210deg);transform:rotate(210deg)}.sk-fading-circle .sk-circle9{-webkit-transform:rotate(240deg);transform:rotate(240deg)}.sk-fading-circle .sk-circle10{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.sk-fading-circle .sk-circle11{-webkit-transform:rotate(300deg);transform:rotate(300deg)}.sk-fading-circle .sk-circle12{-webkit-transform:rotate(330deg);transform:rotate(330deg)}.sk-fading-circle .sk-circle2:before{-webkit-animation-delay:-1.1s;animation-delay:-1.1s}.sk-fading-circle .sk-circle3:before{-webkit-animation-delay:-1s;animation-delay:-1s}.sk-fading-circle .sk-circle4:before{-webkit-animation-delay:-.9s;animation-delay:-.9s}.sk-fading-circle .sk-circle5:before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.sk-fading-circle .sk-circle6:before{-webkit-animation-delay:-.7s;animation-delay:-.7s}.sk-fading-circle .sk-circle7:before{-webkit-animation-delay:-.6s;animation-delay:-.6s}.sk-fading-circle .sk-circle8:before{-webkit-animation-delay:-.5s;animation-delay:-.5s}.sk-fading-circle .sk-circle9:before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.sk-fading-circle .sk-circle10:before{-webkit-animation-delay:-.3s;animation-delay:-.3s}.sk-fading-circle .sk-circle11:before{-webkit-animation-delay:-.2s;animation-delay:-.2s}.sk-fading-circle .sk-circle12:before{-webkit-animation-delay:-.1s;animation-delay:-.1s}@-webkit-keyframes sk-circleFadeDelay{0%,100%,39%{opacity:0}40%{opacity:1}}@keyframes sk-circleFadeDelay{0%,100%,39%{opacity:0}40%{opacity:1}}\"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return AutocompleteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  AutocompleteComponent.prototype.searchInput;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.filteredListElement;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.historyListElement;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.inputKeyUp$;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.inputKeyDown$;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.query;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.filteredList;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.historyList;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.isHistoryListVisible;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.elementRef;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.selectedIdx;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.toHighlight;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.notFound;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.isFocused;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.isOpen;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.isScrollToEnd;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.overlay;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutocompleteComponent.prototype.manualOpen;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutocompleteComponent.prototype.manualClose;\n  /**\n   * Data of items list.\n   * It can be array of strings or array of objects.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.data;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.searchKeyword;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.placeholder;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.heading;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.initialValue;\n  /**\n   * History identifier of history list\n   * When valid history identifier is given, then component stores selected item to local storage of user's browser.\n   * If it is null then history is hidden.\n   * History list is visible if at least one history item is stored.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.historyIdentifier;\n  /**\n   * Heading text of history list.\n   * If it is null then history heading is hidden.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.historyHeading;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.historyListMaxNumber;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.notFoundText;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.isLoading;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.debounceTime;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.disabled;\n  /**\n   * The minimum number of characters the user must type before a search is performed.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.minQueryLength;\n  /**\n   * Focus first item in the list\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.focusFirst;\n  /**\n   * Custom filter function\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.customFilter;\n  /**\n   * Event that is emitted whenever an item from the list is selected.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.selected;\n  /**\n   * Event that is emitted whenever an input is changed.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.inputChanged;\n  /**\n   * Event that is emitted whenever an input is focused.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.inputFocused;\n  /**\n   * Event that is emitted whenever an input is cleared.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.inputCleared;\n  /**\n   * Event that is emitted when the autocomplete panel is opened.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.opened;\n  /**\n   * Event that is emitted when the autocomplete panel is closed.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.closed;\n  /**\n   * Event that is emitted when scrolled to the end of items.\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.scrolledToEnd;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.itemTemplate;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.notFoundTemplate;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.customTemplate;\n  /**\n   * Propagates new value when model changes\n   * @type {?}\n   */\n\n  AutocompleteComponent.prototype.propagateChange;\n  /** @type {?} */\n\n  AutocompleteComponent.prototype.onTouched;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  AutocompleteComponent.prototype.renderer;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete/highlight.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet HighlightPipe = /*#__PURE__*/(() => {\n  class HighlightPipe {\n    /**\n     * @param {?} text\n     * @param {?} search\n     * @param {?=} searchKeyword\n     * @return {?}\n     */\n    transform(text, search, searchKeyword) {\n      /** @type {?} */\n      let pattern = search.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n      pattern = pattern.split(' ').filter(\n      /**\n      * @param {?} t\n      * @return {?}\n      */\n      t => {\n        return t.length > 0;\n      }).join('|');\n      /** @type {?} */\n\n      const regex = new RegExp(pattern, 'gi');\n\n      if (!search) {\n        return text;\n      }\n\n      if (searchKeyword) {\n        /** @type {?} */\n        const name = text[searchKeyword].replace(regex,\n        /**\n        * @param {?} match\n        * @return {?}\n        */\n        match => `<b>${match}</b>`); // copy original object\n\n        /** @type {?} */\n\n        const text2 = Object.assign({}, text); // set bold value into searchKeyword of copied object\n\n        text2[searchKeyword] = name;\n        return text2;\n      } else {\n        return search ? text.replace(regex,\n        /**\n        * @param {?} match\n        * @return {?}\n        */\n        match => `<b>${match}</b>`) : text;\n      }\n    }\n\n  }\n\n  HighlightPipe.ɵfac = function HighlightPipe_Factory(t) {\n    return new (t || HighlightPipe)();\n  };\n\n  HighlightPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"highlight\",\n    type: HighlightPipe,\n    pure: true\n  });\n  return HighlightPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete-lib.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet AutocompleteLibModule = /*#__PURE__*/(() => {\n  class AutocompleteLibModule {}\n\n  AutocompleteLibModule.ɵfac = function AutocompleteLibModule_Factory(t) {\n    return new (t || AutocompleteLibModule)();\n  };\n\n  AutocompleteLibModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AutocompleteLibModule\n  });\n  AutocompleteLibModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule, FormsModule]\n  });\n  return AutocompleteLibModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AutocompleteLibModule, {\n    declarations: function () {\n      return [AutocompleteLibComponent, AutocompleteComponent, HighlightPipe];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [AutocompleteLibComponent, AutocompleteComponent, HighlightPipe];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-ng-autocomplete.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { AutocompleteComponent, AutocompleteLibComponent, AutocompleteLibModule, HighlightPipe }; //# sourceMappingURL=angular-ng-autocomplete.js.map","map":null,"metadata":{},"sourceType":"module"}